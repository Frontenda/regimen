// Generated by CoffeeScript 1.9.2
(function() {
  module.exports = function(chai, utils) {
    var aMethod, aProperty, overwriteAboveMethod, overwriteBelowMethod, overwriteChainableMethodForLength, overwriteDeepEqualMethod, overwriteEqualMethod, overwriteForEquality, overwriteForLength, overwriteLeastMethod, overwriteMethodForEquality, overwriteMethodForLength, overwriteMostMethod;
    aMethod = function(_super) {
      return function(property) {
        var assertion, block;
        switch (property) {
          case "cover":
          case "description":
          case "subtitle":
          case "title":
            block = this._obj;
            utils.flag(this, "block.property", {
              block: block,
              property: property
            });
            assertion = block[property] != null;
            return this.assert(assertion, "expected block " + block.id + " to have a " + property, "expected block " + block.id + " to not have a " + property);
          default:
            return _super.apply(this, arguments);
        }
      };
    };
    aProperty = function(_super) {
      return function() {
        utils.flag(this, "block.property", true);
        return _super.apply(this, arguments);
      };
    };
    chai.Assertion.overwriteChainableMethod("a", aMethod, aProperty);

    /* Equal */
    overwriteForEquality = function(preposition, assertion) {
      return function(_super) {
        return function(value) {
          var actual, block, deep, expected, property, ref;
          ref = utils.flag(this, "block.property"), block = ref.block, property = ref.property;
          deep = utils.flag(this, "deep");
          if (deep) {
            actual = JSON.stringify(block[property]);
            expected = JSON.stringify(value);
          } else {
            actual = block[property];
            expected = value;
          }
          if (property != null) {
            return this.assert(assertion(actual, expected), "expected block " + block.id + " to have a " + property + " " + preposition + " \#{exp} but got \#{act}", "expected block " + block.id + " to not have a " + property + " " + preposition + " \#{exp} but got \#{act}", value, block[property]);
          } else {
            return _super.apply(this, arguments);
          }
        };
      };
    };
    overwriteMethodForEquality = function(name, preposition, assertion) {
      var method;
      method = overwriteForEquality(preposition, assertion);
      return chai.Assertion.overwriteMethod(name, method);
    };
    overwriteEqualMethod = function(name) {
      return overwriteMethodForEquality(name, "equal to", function(property, value) {
        return property === value;
      });
    };
    overwriteDeepEqualMethod = function(name) {
      return overwriteMethodForEquality(name, "deeply equal to", function(property, value) {
        return JSON.stringify(property) === JSON.stringify(value);
      });
    };
    overwriteEqualMethod("equal");
    overwriteEqualMethod("equals");
    overwriteEqualMethod("eq");
    overwriteDeepEqualMethod("eql");
    overwriteDeepEqualMethod("eqls");

    /* Length */
    overwriteForLength = function(preposition, assertion) {
      return function(_super) {
        return function(number) {
          var actual, block, expected, property, ref;
          ref = utils.flag(this, "block.property"), block = ref.block, property = ref.property;
          expected = block[property].length;
          actual = number;
          if ((property != null ? property.length : void 0) != null) {
            return this.assert(assertion(expected, actual), "expected block " + block.id + " to have a " + property + " with length " + preposition + " \#{exp} but length was \#{act}", "expected block " + block.id + " to not have a " + property + " with length " + preposition + " \#{exp} but length was \#{act}", expected, actual);
          } else {
            return _super.apply(this, arguments);
          }
        };
      };
    };
    overwriteChainableMethodForLength = function(name, preposition, assertion) {
      var method, property;
      method = overwriteForLength(preposition, assertion);
      property = function(_super) {
        return function() {
          return _super.apply(this, arguments);
        };
      };
      return chai.Assertion.overwriteChainableMethod("length", method, property);
    };
    overwriteMethodForLength = function(name, preposition, assertion) {
      var method;
      method = overwriteForLength(preposition, assertion);
      return chai.Assertion.overwriteMethod(name, method);
    };
    overwriteChainableMethodForLength("length", "of", function(length, number) {
      return length === number;
    });
    overwriteLeastMethod = function(name) {
      return overwriteMethodForLength(name, "at least", function(length, number) {
        return length >= number;
      });
    };
    overwriteLeastMethod("least");
    overwriteLeastMethod("gte");
    overwriteMostMethod = function(name) {
      return overwriteMethodForLength(name, "at most", function(length, number) {
        return length <= number;
      });
    };
    overwriteMostMethod("most");
    overwriteMostMethod("lte");
    overwriteAboveMethod = function(name) {
      return overwriteMethodForLength(name, "above", function(length, number) {
        return length > number;
      });
    };
    overwriteAboveMethod("above");
    overwriteAboveMethod("gt");
    overwriteAboveMethod("greaterThan");
    overwriteBelowMethod = function(name) {
      return overwriteMethodForLength(name, "below", function(length, number) {
        return length < number;
      });
    };
    overwriteBelowMethod("below");
    overwriteBelowMethod("lt");
    return overwriteBelowMethod("lessThan");
  };

}).call(this);
